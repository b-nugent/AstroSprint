<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Phaser - Making your first game, part 1</title>
	<script type="text/javascript" src="js/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
// Full Docs: http://docs.phaser.io
// Phase.Game() Docs: http://docs.phaser.io/Phaser.Game.html
    
"use strict";

var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });
var platforms = undefined;
var player = undefined;
var planets = undefined;
var cursors = undefined;
var stars = undefined;
var wormholes = undefined;
var totalScore = 0;
var roundScore = 0;
var scoreText = undefined;
//var targetPlanet = undefined;
var offGround = false;
//var roundOver = false;
var GAME_STATE_MENU = 0;
var GAME_STATE_PLAY = 1;
var GAME_STATE_ROUND_OVER = 2;
var GAME_STATE_ROUND_REPEAT = 3;
var GAME_STATE_GAME_OVER = 4;
var GAME_STATE_PAUSE = 5;
var currentState = GAME_STATE_PLAY;

function preload() {
	game.load.image('sky', 'assets/sky.png');
    game.load.image('wormhole', 'assets/diamond.png');
	game.load.image('star', 'assets/star.png');
    game.load.image('planet', 'assets/circle.png');
	game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
}

function create() {
	//start the physics system
	game.physics.startSystem(Phaser.Physics.P2JS);
    // Arcade needs to be active for stars to work.
    //game.physics.startSystem(Phaser.Physics.ARCADE);
    
    scoreText = game.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#F0F' });

    
    //add simple planet
    //planet1 = game.add.sprite(game.world.width/2, game.world.height/2, 'planet');
	//planet2 = game.add.sprite(600, 150, 'planet');
    
    //add planets
    planets = game.add.group();

    var planet1 = planets.create(game.world.width/2, game.world.height/2, 'planet');
    game.physics.p2.enable(planet1, false);
    planet1.body.static = true;
	planet1.anchor.setTo(0.5, 0.5);  
	planet1.body.setCircle(92); 
    
    var planet2 = planets.create(600, 150, 'planet');
    game.physics.p2.enable(planet2, false);
    planet2.body.static = true;
	planet2.anchor.setTo(0.5, 0.5);  
	planet2.body.setCircle(48);
    planet2.scale = new Phaser.Point(0.5, 0.5);
    
	//player
    player = game.add.sprite(planet1.x, planet1.y - (planet1.width / 2 + 9), 'dude');
	player.animations.add('left', [0,1,2,3], 10, true);
    player.animations.add('right', [5,6,7,8], 10, true);
    game.physics.p2.enable(player, false);
    player.body.collideWorldBounds = true;
    player.body.velocity.x = 1;
    player.anchor.setTo(0.5, 0.5);
    player.grounded = false;
    player.targetPlanet = planet1;
    player.jumpStrength = 10000;
    player.slamStrength = 5000;
    player.runSpeed = 300;
    
    
    cursors = game.input.keyboard.createCursorKeys();
    
    //add a group of stars to the game
    stars = game.add.group();
    var star1 = stars.create(500, 250, 'star');
    game.physics.p2.enable(star1, false);
	star1.anchor.setTo(0.5, 0.5);  
    var star2 = stars.create(planet1.x, planet1.y + (planet1.width / 2) + 90, 'star');
    game.physics.p2.enable(star2, false);
	star2.anchor.setTo(0.5, 0.5);  
    var star3 = stars.create(planet2.x + (planet2.width / 2), planet2.y - (planet2.width / 2), 'star');
    game.physics.p2.enable(star3, false);
	star3.anchor.setTo(0.5, 0.5);
    
    // Create and setup the wormhole
    wormholes = game.add.group();
    var wormhole = wormholes.create(600, 215, 'wormhole');
    game.physics.p2.enable(wormhole, false);
    wormhole.anchor.setTo(0.5, 0.5);

    
    
    player.body.onBeginContact.add(playerContact, this);
    player.body.onEndContact.add(playerEndContact, this);
}

function update() {
    if (currentState == GAME_STATE_PLAY) {
        playerForceReset(player);

        //calculate the angle between the player and the planet
        var angle = Math.atan2(player.targetPlanet.y - player.y, player.targetPlanet.x - player.x);
        player.body.rotation = angle + game.math.degToRad(90) * -1;

        if(player.grounded)
        {
            //move player
            playerMove(player, angle);

            //allow player jump if they are touching the ground
            if(cursors.up.isDown)
            {
                playerJump(player, angle);
                player.grounded = false;
            }
        }
        else{
            calculateTargetPlanet(player, planets);
        }


        //calculate gravity
        var strength = 500;
        applyGravity(player, angle, strength);

        //allow the player to fall if not grounded
        if(cursors.down.isDown && !player.grounded)
        {
            playerFall(player, angle);
        }

        //player.body.angularVelocity = clampSpeed(player);
    } else if(currentState == GAME_STATE_ROUND_OVER) {
        //CLEAR THE SCREEN
        //SHOW TEXT
        // Adds the round score to the total score and clears the round score
        totalScore += roundScore;
        roundScore = 0;
    }
}
    
    //calculate which planet the player should be attracted to
    function calculateTargetPlanet(player, planets)
    {
        var targetMagnitude = new Phaser.Point(player.targetPlanet.y - player.y, player.targetPlanet.x - player.x).getMagnitude();
        var closestPlanet = undefined;
        
        for(var i = 0; i < planets.children.length; i++)
        {
            var p = planets.children[i];
            var testMagnitude = new Phaser.Point(p.y - player.y, p.x - player.x).getMagnitude();
            
            if(testMagnitude < targetMagnitude)
            {
                closestPlanet = p;
            }
        }
        
        if(closestPlanet != undefined)
        {
            player.targetPlanet = closestPlanet;
        }
        /*
        //should we be attracted to a new planet)
		if(offGround){
			if(player.targetPlanet === planet1){
				if(game.physics.arcade.distanceBetween(planet2,player) < 125){
					player.targetPlanet = planet2;
					offGround = false;
				}
			}
			else{
				if(game.physics.arcade.distanceBetween(planet1,player) < 125){
					player.targetPlanet = planet1;
					offGround = false;
				}
			}
		}*/
    }
    
    //be attracted toward the center of the planet
    function applyGravity(player, angle, strength)
    {
        player.body.force.x += Math.cos(angle) * strength;
        player.body.force.y += Math.sin(angle) * strength;
    }
    
    //move the player
    function playerMove(player, angle)
    {
        var speed = player.runSpeed;
        
        player.animations.play('left');
        player.body.force.x += Math.cos(angle + 90) * speed;
        player.body.force.y += Math.sin(angle + 90) * speed;
        
        /*if(player.body.angularVelocity < 0)
        {
            player.animations.play('left');
            player.body.force.x += Math.cos(angle + 90) * speed;
            player.body.force.y += Math.sin(angle + 90) * speed;
        }
        else
        {
            player.animations.play('right');
            player.body.force.x += Math.cos(angle + 90) * speed;
            player.body.force.y += Math.sin(angle + 90) * speed;
        }*/

    }
    
    //player jump
    function playerJump(player, angle) {
        
        var speed = player.jumpStrength;
        
		if (angle > 0){
            if(angle > game.math.degToRad(90)) {
                // Quadrant II, sin is positive
                player.body.force.x += Math.abs(Math.cos(angle) * speed);
                player.body.force.y += Math.abs(Math.sin(angle) * speed) * -1;
            } else {
                // Quadrant I, both are positve
                player.body.force.x += Math.abs(Math.cos(angle * -1) * speed) * -1;
                player.body.force.y += Math.abs(Math.sin(angle * -1) * speed) * -1;
            }
		} else {
            if (angle > game.math.degToRad(-90)) {
                // Quadrant III, neither are positive
                player.body.force.x += Math.abs(Math.cos(angle) * speed) * -1;
                player.body.force.y += Math.abs(Math.sin(angle) * speed);
            } else {
                // Quadrant IV, cos is positive
                player.body.force.x += Math.abs(Math.cos(angle * -1) * speed);
                player.body.force.y += Math.abs(Math.sin(angle * -1) * speed);
            }
		}
    }
    
    function playerFall(player, angle) {
        
        var speed = player.slamStrength;
        
        player.body.force.x += Math.cos(angle) * speed;
        player.body.force.y += Math.sin(angle) * speed;
    }
    
    //reset the forces on the player to 0
    function playerForceReset(player) {
        player.body.force.x = 0;
        player.body.force.y = 0;
    }
    
    //logic for collision detection
    function playerContact(body, shapeA, shapeB, equation)
    {
        if(body != null)
        {
            switch(body.sprite.key){
                    case "planet":
                        setGrounded();
                        break;
                    case "star":
                        collectStar(body);
                        break;
                    case "wormhole":
                        //collideWormhole(wormhole);
                        currentState = GAME_STATE_ROUND_OVER;
                        break;
            }
        }
    }
    function playerEndContact(body, shapeA, shapeB, equation)
    {
        if(body != null && body.sprite != null)
        {
            switch(body.sprite.key){
                    case "planet":
                        setGrounded();
                        break;
            }
        }
    }
    
    function collectStar(star)
    {
        //removes the star from the screen
        //star.alive = false;
        star.sprite.exists = false;
        star.destroy();
        
        roundScore += 10;
        scoreText.text = 'Score: ' + roundScore;
    }
    
    
    function setGrounded()
    {
        player.grounded = !player.grounded;
    }
    
    /*
    function getMag(x, y) {
        //var vector = new Phaser.Point(x, y);
        //var magnitude = vector.getMagnitude();
        var magnitude = Math.sqrt((x * x) + (y * y));
        return magnitude;
    }
    
    function normalizeVector(vector) {
        var normalizedX = vector.x / getMag(vector.x, vector.y);
        var normalizedY = vector.x / getMag(vector.x, vector.y);
        var normalizedVector = new Phaser.Vector(normalizedX, normalizedY);
        return normalizedVector;
    }
    
    function clampSpeed(player) {
        //var body = player.body;
        var currentSpeed = getMag(player.body.angularVelocity.x, player.body.angularVelocity.y);
        //var currentSpeed = player.body.angularVelocity;
        //console.log("X: " + player.body.velocity.x + " Y: " + player.body.velocity.y);
        //var currentSpeed = player.body.velocity.getMagnitude();
        //console.log("CurrentSpeed: " + currentSpeed);
        //console.log(player.body.angularVelocity);
        var maxSpeed = -5;
        var minSpeed = 0.5;
        if(currentSpeed < maxSpeed || currentSpeed > minSpeed) {
            //debugger;
            // Issue here when you make a point from the angular velocity (it becomes a 0,0 point.
            //var point = new Phaser.Point(player.body.angularVelocity.x, player.body.angularVelocity.y);
            //var newVector = point.normalize();
            //newVector *= maxSpeed;
            //return newVector;
            var newSpeed = normalizeVector(player.body.angularVelocity) * maxSpeed;
            return newSpeed;
        } else {
            return player.body.angularVelocity;
        }
        /*
        if (currentSpeed < 0) {
            currentSpeed = 0;
            return currentSpeed;
        }
        
        return currentSpeed;
    }*/

</script>

</body>
</html>